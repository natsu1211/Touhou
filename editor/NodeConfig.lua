function CalcParamNum(s)	if string.match(s,"^[%s]*$") then return 0 end	local b1=0 local b2=0 local ret=1	for i=1,#s do		local c=string.byte(s,i)		if b1==0 and b2==0 and c==44 then ret=ret+1		elseif c==40 then b1=b1+1		elseif c==41 then b1=b1-1		elseif c==123 then b2=b2+1		elseif c==125 then b2=b2-1		end	end	return retendlocal function CheckName(s)	if string.match(s,"^[%w_][%w_ ]*$")==nil then return "must be a string of letters, digits, spaces, and underscores, not beginning with a space" endendlocal function CheckVName(s)	if string.match(s,"^[%a_][%w_]*$")==nil then return "must be a string of letters, digits, and underscores, not beginning with a digit" endendlocal function CheckExpr(s)	if string.match(s,"^[%s]*$") then return "can not be omitted" end	local _,msg=loadstring("return "..s)	if msg~=nil then return msg endendlocal function CheckPos(s)	if string.match(s,"^[%s]*$") then return "can not be omitted" end	local _,msg=loadstring("return "..s)	if msg~=nil then return msg end	if CalcParamNum(s)~=2 then return "invalid expression of position" endendlocal function CheckExprOmit(s)	local _,msg=loadstring("return "..s)	if msg~=nil then return msg endendlocal function CheckCode(s)	local _,msg=loadstring(s)	if msg~=nil then return msg endendlocal function CheckParam(s)	local _,msg=loadstring("return function("..s..") end")	if msg~=nil then return msg endendlocal function CheckNonBlank(s)	if string.match(s,"^[%s]*$") then return "can not be blank" endendlocal function CheckClassName(s)	if string.match(s,"^[%s]*$") then return "can not be blank"	else		if checkClassName[s] then return string.format("repeated type name %q",s)		else checkClassName[s]=true end	endendlocal function IsBlank(s)	if string.match(s,"^[%s]*$") then return true else return false endendlocal function CheckResFileInPack(name)	if checkResFile[name]==nil then checkResFile[name]=true return true else return false endendlocal function CheckAnonymous(name,fullname)	if checkResFile[name]==nil then		checkResFile[name]=true		checkAnonymous[name]=fullname		return true	else		if checkAnonymous[name]==fullname then return true else return false end	endendclassName=nilparimg={}for i=1,16 do parimg['parimg'..i]=true endevent_type_dict={frame=true,render=true,colli=true,kill=true,del=true}nodeType={	['setting']={		{'Output name','any',CheckName},		{'Author','any',CheckName},		{'Allow practice','bool',CheckExpr},		{'Allow sc practice','bool',CheckExpr},		disptype='project settings',		totext=function(nodedata) return 'project settings' end,		allowparent={},		allowchild={},		forbiddelete=true,		tohead=function(nodedata)			return string.format("-- Generated by LuaSTG editor\n-- Mod name: %s\n_author=%q\n_mod_version=%d\n_allow_practice=%s\n_allow_sc_practice=%s\n\n",				nodedata.attr[1],nodedata.attr[2],_luastg_version,nodedata.attr[3],nodedata.attr[4])		end,	},	folder={		{'Title','any'},		allowparent={'root','folder'},		depth=0,		totext=function(nodedata) return nodedata.attr[1] end,	},	-- language	codeblock={		{'Title','any'},		disptype='code block',		forbidparent={'root','folder'},		totext=function(nodedata) return nodedata.attr[1] end,		tohead=function(nodedata) return "do\n" end,		tofoot=function(nodedata) return "end\n" end,	},	code={		{'Code','any',CheckCode},		allowchild={},		editfirst=true,		totext=function(nodedata)			local start,finish=string.find(nodedata.attr[1],'^.-\n')			if start==nil then return nodedata.attr[1]			else return string.sub(nodedata.attr[1],1,finish-1)..' ...' end		end,		tohead=function(nodedata) return nodedata.attr[1].."\n" end,	},	comment={		{'Comment','any'},		allowchild={},		editfirst=true,		totext=function(nodedata) return "[comment] "..nodedata.attr[1] end,		tohead=function(nodedata) return "--[[ "..nodedata.attr[1].." --]]\n" end,	},	variable={		{'Name','any',CheckVName},		{'Initial value','any',CheckExprOmit},		disptype='define variable',		editfirst=true,		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata)			if IsBlank(nodedata.attr[2]) then return 'define local variable '..nodedata.attr[1]			else return 'define local variable '..nodedata.attr[1].." = "..nodedata.attr[2] end		end,		tohead=function(nodedata)			if IsBlank(nodedata.attr[2]) then return 'local '..nodedata.attr[1].."\n"			else return 'local '..nodedata.attr[1].." = "..nodedata.attr[2].."\n" end		end,	},	['repeat']={		{'Number of times','any',CheckExpr},		{'Var 1 name','any'},		{'Var 1 init value','any'},		{'Var 1 increment','any'},		{'Var 2 name','any'},		{'Var 2 init value','any'},		{'Var 2 increment','any'},		{'Var 3 name','any'},		{'Var 3 init value','any'},		{'Var 3 increment','any'},		{'Var 4 name','any'},		{'Var 4 init value','any'},		{'Var 4 increment','any'},		default={["type"]='repeat',attr={'_infinite','','','','','','','','','','','',''}},		forbidparent={'root','folder'},		check=function(nodedata)			local attr=nodedata.attr			for i=2,11,3 do				if not IsBlank(attr[i]) then					local msg=CheckVName(attr[i])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["repeat"][i][1],msg) end					msg=CheckExpr(attr[i+1])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["repeat"][i+1][1],msg) end					msg=CheckExpr(attr[i+2])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["repeat"][i+2][1],msg) end				end			end		end,		totext=function(nodedata)			local ret="repeat "..nodedata.attr[1].." times"			local attr=nodedata.attr			for i=2,11,3 do				if not IsBlank(attr[i]) then					ret=ret.." ("..attr[i].."="..attr[i+1]..",increment "..attr[i+2]..")"				end			end			return ret		end,		tohead=function(nodedata)			local ret="do "			local attr=nodedata.attr			for i=2,11,3 do				if not IsBlank(attr[i]) then					ret=ret..string.format("local %s,%s=(%s),(%s) ",attr[i],"_d_"..attr[i],attr[i+1],attr[i+2])				end			end			return ret.."for _=1,"..nodedata.attr[1].." do\n"		end,		tofoot=function(nodedata)			local ret=""			local attr=nodedata.attr			for i=2,11,3 do				if not IsBlank(attr[i]) then					ret=ret..string.format("%s=%s+%s ",attr[i],attr[i],"_d_"..attr[i])				end			end			return ret.."end end\n"		end,	},	['break']={		needancestor={'repeat','taskrepeat'},		allowchild={},		totext=function(nodedata) return "break" end,		tohead=function(nodedata) return "if true then break end\n" end,	},	['if']={		{'Condition','any',CheckExpr},		editfirst=true,		forbidparent={'root','folder'},		depth=0,		allowchild={},		totext=function(nodedata) return "if "..nodedata.attr[1] end,		default={["attr"]={""},["type"]="if",expand=true,child={{["attr"]={},["type"]="then"},{["attr"]={},["type"]="else"}}},		tohead=function(nodedata) return "if "..nodedata.attr[1].." then\n" end,		tofoot=function(nodedata) return "end\n" end,	},	['then']={		totext=function(nodedata) return "then" end,		allowparent={},		forbiddelete=true,	},	['else']={		totext=function(nodedata) return "else" end,		allowparent={},		forbiddelete=true,		tohead=function(nodedata) return "else\n" end,	},	-- stage	stagegroup={		{'Name','any',CheckName},		{'Start life','any',CheckExpr},		{'Start power','any',CheckExpr},		{'Start faith','any',CheckExpr},		{'Allow practice','bool',CheckExpr},		disptype='stage group',		editfirst=true,		default={["type"]='stagegroup',attr={'','2','0','50000','true'}},		allowchild={'stage'},		allowparent={'root','folder'},		depth=0,		totext=function(nodedata) return string.format("stage group %q",nodedata.attr[1]) end,		tohead=function(nodedata) stageGroupName=nodedata.attr[1] return string.format("stage.group.New('menu',{},%q,{lifeleft=%s,power=%s,faith=%s},%s)\n",			nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5]) end,	},	stage={		{'Name','any',CheckName},		{'Start life (practice)','any',CheckExpr},		{'Start power (practice)','any',CheckExpr},		{'Start faith (practice)','any',CheckExpr},		{'Allow practice','bool',CheckExpr},		editfirst=true,		allowparent={'stagegroup'},		allowchild={},		depth=1,		default={expand=true,["type"]='stage',attr={'','7','300','50000','true'},child={{["type"]='stagetask',attr={}}}},		totext=function(nodedata) return string.format("stage %q",nodedata.attr[1]) end,		tohead=function(nodedata)			local ret=string.format("stage.group.AddStage('%s','%s@%s',{lifeleft=%s,power=%s,faith=%s},%s)\nstage.group.DefStageFunc('%s@%s','init',function(self)\n    _init_item(self)\n    New(mask_fader,'open')\n    New(_G[lstg.var.player_name])\n",				stageGroupName,				nodedata.attr[1],				stageGroupName,				nodedata.attr[2],				nodedata.attr[3],				nodedata.attr[4],				nodedata.attr[5],				nodedata.attr[1],				stageGroupName)			return ret		end,		tofoot=function(nodedata) return "    task.New(self,function()\		while coroutine.status(self.task[1])~='dead' do task.Wait() end\		New(mask_fader,'close')\		_stop_music()\		task.Wait(30)\		stage.group.FinishStage()\	end)\end)\n" end,	},	stagetask={		disptype='task for stage',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return "create task" end,		tohead=function(nodedata) return "task.New(self,function()\n" end,		tofoot=function(nodedata) return "end)\n" end,	},	stagefinish={		needancestor={'stage'},		disptype='finish stage',		allowchild={},		totext=function(nodedata) return "finish current stage" end,		tohead=function(nodedata) return "if true then return end\n" end,	},	stagegoto={		{'Stage (by index)','any',CheckExpr},		disptype='go to stage',		needancestor={'stage'},		allowchild={},		totext=function(nodedata) return "go to stage "..nodedata.attr[1] end,		tohead=function(nodedata) return "New(mask_fader,'close') _stop_music() task.Wait(30) stage.group.GoToStage("..nodedata.attr[1]..")\n" end,	},	stagefinishgroup={		disptype='finish stage group',		needancestor={'stage'},		allowchild={},		totext=function(nodedata) return "finish current game and return to title" end,		tohead=function(nodedata) return "New(mask_fader,'close') _stop_music() task.Wait(30) stage.group.FinishGroup()\n" end,	},	bgstage={		{'Background','bgstage',CheckVName},		disptype='set stage background',		needancestor={'stage'},		allowchild={},		totext=function(nodedata) return string.format("set current stage's background to %q",nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("New(%s_background)\n",nodedata.attr[1]) end,	},	-- task	task={		needancestor={'enemydefine','bossdefine','objectdefine','laserdefine','bulletdefine'},		totext=function(nodedata) return "create task" end,		tohead=function(nodedata) return "task.New(self,function()\n" end,		tofoot=function(nodedata) return "end)\n" end,	},	taskclear={		disptype='clear task',		needancestor={'enemydefine','bossdefine','objectdefine','laserdefine','bulletdefine'},		allowchild={},		totext=function(nodedata) return "clear all task(s)" end,		tohead=function(nodedata) return "task.Clear(self)\n" end,	},	taskwait={		{'nFrame','any',CheckExpr},		disptype='wait',		default={["type"]='taskwait',attr={'60'}},		needancestor={'task','stagetask','dialogtask'},		allowchild={},		totext=function(nodedata)			return "wait "..nodedata.attr[1].." frame(s)"		end,		tohead=function(nodedata)			return "task._Wait("..nodedata.attr[1]..")\n"		end,	},	taskrepeat={		{'Number of times','any',CheckExpr},		{'Interval (in frames)','any',CheckExpr},		{'Var 1 name','any'},		{'Var 1 init value','any'},		{'Var 1 increment','any'},		{'Var 2 name','any'},		{'Var 2 init value','any'},		{'Var 2 increment','any'},		{'Var 3 name','any'},		{'Var 3 init value','any'},		{'Var 3 increment','any'},		{'Var 4 name','any'},		{'Var 4 init value','any'},		{'Var 4 increment','any'},		disptype='repeat',		default={["type"]='taskrepeat',attr={'_infinite','60','','','','','','','','','','','',''}},		needancestor={'task','stagetask','dialogtask'},		check=function(nodedata)			local attr=nodedata.attr			for i=3,12,3 do				if not IsBlank(attr[i]) then					local msg=CheckVName(attr[i])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["taskrepeat"][i][1],msg) end					msg=CheckExpr(attr[i+1])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["taskrepeat"][i+1][1],msg) end					msg=CheckExpr(attr[i+2])					if msg then return string.format("Attribution '%s' is invalid: %s",nodeType["taskrepeat"][i+2][1],msg) end				end			end		end,		totext=function(nodedata)			local ret="repeat "..nodedata.attr[1].." times"			local attr=nodedata.attr			if not IsBlank(attr[2]) then ret=ret..",interval "..attr[2].." frame(s)" end			for i=3,12,3 do				if not IsBlank(attr[i]) then					ret=ret.." ("..attr[i].."="..attr[i+1]..",increment "..attr[i+2]..")"				end			end			return ret		end,		tohead=function(nodedata)			local ret="do "			local attr=nodedata.attr			for i=3,12,3 do				if not IsBlank(attr[i]) then					ret=ret..string.format("local %s,%s=(%s),(%s) ",attr[i],"_d_"..attr[i],attr[i+1],attr[i+2])				end			end			return ret.."for _=1,"..nodedata.attr[1].." do\n"		end,		tofoot=function(nodedata)			local ret=""			local attr=nodedata.attr			if not IsBlank(attr[2]) then ret=ret.."    task._Wait("..attr[2]..")\n" end			for i=3,12,3 do				if not IsBlank(attr[i]) then					ret=ret..string.format("%s=%s+%s ",attr[i],attr[i],"_d_"..attr[i])				end			end			return ret.."end end\n"		end,	},	taskbreak={		needancestor={'repeat','taskrepeat'},		disptype='jump',		allowchild={},		totext=function(nodedata) return "jump out of current repeat" end,		tohead=function(nodedata) return "if true then break end\n" end,	},	taskreturn={		needancestor={'task','dialogtask'},		disptype='terminate task',		allowchild={},		totext=function(nodedata) return "terminate current task" end,		tohead=function(nodedata) return "if true then return end\n" end,	},	taskmoveto={		{'Destination','any',CheckExpr},		{'nFrame','any',CheckExprOmit},		{'Mode','movetomode',CheckExprOmit},		disptype='move to',		needancestor={'task','dialogtask'},		allowchild={},		default={["attr"]={"0,0","60","MOVE_NORMAL"},["type"]="taskmoveto"},		totext=function(nodedata)			local nf			if IsBlank(nodedata.attr[2]) then nf='1' else nf=nodedata.attr[2] end			return "move to ("..nodedata.attr[1]..") in "..nf.." frame(s)"		end,		tohead=function(nodedata)			local nf,mode			if IsBlank(nodedata.attr[2]) then nf='1' else nf=nodedata.attr[2] end			if IsBlank(nodedata.attr[3]) then mode='MOVE_NORMAL' else mode=nodedata.attr[3] end			return string.format("task.MoveTo(%s,%s,%s)\n",nodedata.attr[1],nf,mode)		end,	},	taskbosswander={		{'nFrame','any',CheckExprOmit},		disptype='boss wander',		default={["attr"]={"30"},["type"]="taskbosswander"},		needancestor={'task'},		forbidancestor={'bulletdefine','objectdefine','laserdefine','enemydefine'},		allowchild={},		totext=function(nodedata)			local nf			if IsBlank(nodedata.attr[1]) then nf='1' else nf=nodedata.attr[1] end			return "boss wander "..nf.." frame(s)"		end,		tohead=function(nodedata)			local nf			if IsBlank(nodedata.attr[1]) then nf='1' else nf=nodedata.attr[1] end			return string.format("task.MoveToPlayer(%s)\n",nf)		end,	},	--	callbackfunc={		{'Event type','event',CheckNonBlank},		disptype='redefine call back function',		default={expand=true,['type']='callbackfunc',attr={'frame'},child={{['type']='defaultaction',attr={}}}},		allowparent={'enemydefine','bossdefine','objectdefine','laserdefine','bulletdefine'},		totext=function(nodedata) return "on "..nodedata.attr[1] end,		tohead=function(nodedata)			eventType=nodedata.attr[1]			if nodedata.attr[1]~='colli' then return string.format("_editor_class[%q].%s=function(self)\n",className,nodedata.attr[1])			else return string.format("_editor_class[%q].colli=function(self,other)\n",className) end		end,		tofoot=function(nodedata) return "end\n" end,		check=function(nodedata)			if not event_type_dict[nodedata.attr[1]] then return string.format("unknown event type %q",nodedata.attr[1]) end		end,	},	defaultaction={		disptype='do default action',		allowchild={},		allowparent={'callbackfunc'},		totext=function(nodedata) return "do default action" end,		tohead=function(nodedata)			if eventType=='colli' then				return "self.class.base.colli(self,other)\n"			else				return string.format("self.class.base.%s(self)\n",eventType)			end		end	},	--	enemydefine={		{'Type name','any',CheckClassName},		disptype='define enemy',		editfirst=true,		allowparent={'root','folder'},		allowchild={'callbackfunc'},		totext=function(nodedata) return string.format("define enemy type %q",nodedata.attr[1]) end,		depth=0,		watch='enemydefine',		default=		{			["attr"]={				[1]="",			},			["type"]="enemydefine",			["expand"]=true,			["child"]={				[1]={					["attr"]={"","1","10","0,0","0","0","0","1","false","true"},					["type"]="enemyinit",					["expand"]=true,					["child"]={						[1]={							["attr"]={							},							["type"]="task",							["child"]={							},						},					},				},			},		},		tohead=function(nodedata) className=nodedata.attr[1] return string.format("_editor_class[%q]=Class(enemy)\n",className) end,	},	enemyinit={		{'Parameter list','any',CheckParam},		{'Style','selectenemystyle',CheckExpr},		{'Hit point','any',CheckExpr},		{'Position','any',CheckPos},		{'Drop power item','any',CheckExpr},		{'Drop faith item','any',CheckExpr},		{'Drop point item','any',CheckExpr},		{'Protect (nframes)','any',CheckExpr},		{'Clear bullets when die','bool',CheckExpr},		{'Delete when leave screen','bool',CheckExpr},		disptype='on create enemy',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return string.format("on create: (%s)",nodedata.attr[1]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[1]) then p='_' else p=nodedata.attr[1] end			return string.format("_editor_class[%q].init=function(self,%s)\    enemy.init(self,%s,%s,%s,%s)\    self.x,self.y=%s\    self.drop={%s,%s,%s}\    task.New(self,function() self.protect=true task.Wait(%s) self.protect=false end)\",className,p,nodedata.attr[2],nodedata.attr[3],nodedata.attr[9],nodedata.attr[10],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8]) end,		tofoot=function(nodedata) return "end\n" end,	},	enemycreate={		{'Type name','selecttype',CheckNonBlank},		{'Parameter','param',CheckExprOmit},		disptype='create enemy',		editfirst=true,		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format("create enemy of type %q with parameter %s",nodedata.attr[1],nodedata.attr[2]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[2]) then p="_" else p=nodedata.attr[2] end			return string.format("last=New(_editor_class[%q],%s)\n",nodedata.attr[1],p)		end,		check=function(nodedata)			if not watchDict.enemydefine[nodedata.attr[1]] then return string.format('enemy type %q does not exist',nodedata.attr[1]) end			if paramNumDict[nodedata.attr[1]]~=CalcParamNum(nodedata.attr[2]) then return "number of parameter is incorrect" end		end,	},	--	laserdefine={		{'Type name','any',CheckClassName},		disptype='define laser',		editfirst=true,		allowparent={'root','folder'},		allowchild={'callbackfunc'},		totext=function(nodedata) return string.format("define laser type %q",nodedata.attr[1]) end,		depth=0,		watch='laserdefine',		default=		{			["attr"]={				[1]="",			},			["type"]="laserdefine",			["expand"]=true,			["child"]={				[1]={					["attr"]={'','COLOR_RED','64','32','64','8','0'},					["type"]="laserinit",					["expand"]=true,					["child"]={						[1]={							["attr"]={							},							["type"]="task",							["expand"]=true,							["child"]={								[1]={['type']='laserturnon',attr={'30','true','true'}},							},						},					},				},			},		},		tohead=function(nodedata) className=nodedata.attr[1] return string.format("_editor_class[%q]=Class(laser)\n",className) end,	},	laserinit={		{'Parameter list','any',CheckParam},		{'Color','color',CheckExpr},		{'Head length','any',CheckExpr},		{'Body length','any',CheckExpr},		{'Tail length','any',CheckExpr},		{'Width','any',CheckExpr},		{'Node size','any',CheckExpr},		disptype='on create laser',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return string.format("on create: (%s)",nodedata.attr[1]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[1]) then p='_' else p=nodedata.attr[1] end			return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\    laser.init(self,%s,_x,_y,0,%s,%s,%s,%s,%s)\",className,p,nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[7]) end,		tofoot=function(nodedata) return "end\n" end,	},	lasercreate={		{'Type name','selecttype',CheckNonBlank},		{'Position','any',CheckPos},		{'Parameter','param',CheckExprOmit},		disptype='create laser',		editfirst=true,		default={["type"]='lasercreate',attr={'','self.x,self.y',''}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format("create laser of type %q with parameter %s",nodedata.attr[1],nodedata.attr[3]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[3]) then p="_" else p=nodedata.attr[3] end			return string.format("last=New(_editor_class[%q],%s,%s)\n",nodedata.attr[1],nodedata.attr[2],p)		end,		check=function(nodedata)			if not watchDict.laserdefine[nodedata.attr[1]] then return string.format('laser type %q does not exist',nodedata.attr[1]) end			if paramNumDict[nodedata.attr[1]]~=CalcParamNum(nodedata.attr[3]) then return "number of parameter is incorrect" end		end,	},	laserturnon={		{'time (in frames)','any',CheckExpr},		{'Play sound effect','bool',CheckExpr},		{'wait in this task','bool',CheckExpr},		disptype='turn on laser',		needancestor={'laserdefine'},		default={['type']='laserturnon',attr={'30','true'}},		totext=function(nodedata) return string.format("turn on in %s frame(s)",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("laser._TurnOn(self,%s,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3])		end,	},	laserturnoff={		{'time (in frames)','any',CheckExpr},		{'wait in this task','bool',CheckExpr},		disptype='turn off laser',		needancestor={'laserdefine'},		default={['type']='laserturnoff',attr={'30'}},		totext=function(nodedata) return string.format("turn off in %s frame(s)",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("laser._TurnOff(self,%s,%s)\n",nodedata.attr[1],nodedata.attr[2])		end,	},	laserturnhalfon={		{'time (in frames)','any',CheckExpr},		{'wait in this task','bool',CheckExpr},		disptype='turn half on laser',		needancestor={'laserdefine'},		default={['type']='laserturnhalfon',attr={'30'}},		totext=function(nodedata) return string.format("turn half on in %s frame(s)",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("laser._TurnHalfOn(self,%s,%s)\n",nodedata.attr[1],nodedata.attr[2])		end,	},	--	bulletdefine={		{'Type name','any',CheckClassName},		disptype='define bullet',		editfirst=true,		allowparent={'root','folder'},		allowchild={'callbackfunc'},		totext=function(nodedata) return string.format("define bullet type %q",nodedata.attr[1]) end,		depth=0,		watch='bulletdefine',		default=		{			["attr"]={""},			["type"]="bulletdefine",			["expand"]=true,			["child"]={				[1]={					["attr"]={"","arrow_big","COLOR_RED","true","true"},					["type"]="bulletinit",					},				},			},		tohead=function(nodedata) className=nodedata.attr[1] return string.format("_editor_class[%q]=Class(bullet)\n",className) end,	},	bulletinit={		{'Parameter list','any',CheckParam},		{'Style','bulletstyle',CheckExpr},		{'Color','color',CheckExpr},		{'Stay on create','bool',CheckExpr},		{'Destroyable','bool',CheckExpr},		disptype='on create bullet',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return string.format("on create: (%s)",nodedata.attr[1]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[1]) then p="_" else p=nodedata.attr[1] end			return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\    bullet.init(self,%s,%s,%s,%s)\    self.x,self.y=_x,_y\",className,p,nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5]) end,		tofoot=function(nodedata) return "end\n" end,	},	bulletcreate={		{'Type name','selecttype',CheckNonBlank},		{'Position','any',CheckPos},		{'Parameter','param',CheckExprOmit},		disptype='create bullet',		editfirst=true,		default={["type"]='bulletcreate',attr={'','self.x,self.y',''}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format("create bullet of type %q at (%s) with parameter %s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[3]) then p="_" else p=nodedata.attr[3] end			return string.format("last=New(_editor_class[%q],%s,%s)\n",nodedata.attr[1],nodedata.attr[2],p)		end,		check=function(nodedata)			if not watchDict.bulletdefine[nodedata.attr[1]] then return string.format('bullet type %q does not exist',nodedata.attr[1]) end			if paramNumDict[nodedata.attr[1]]~=CalcParamNum(nodedata.attr[3]) then return "number of parameter is incorrect" end		end,	},	bulletcreatestraight={		{'Style','bulletstyle',CheckExpr},		{'Color','color',CheckExpr},		{'Position','any',CheckPos},		{'Velocity','any',CheckExpr},		{'Angle','any',CheckExpr},		{'Aim to player','bool',CheckExpr},		{'Rotation Velocity','any',CheckExpr},		{'Stay on create','bool',CheckExpr},		{'Destroyable','bool',CheckExpr},		disptype='create simple bullet',		default={['type']='bulletcreatestraight',attr={'arrow_big','COLOR_RED','self.x,self.y','3','0','false','0','true','true'}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata)			local ret=string.format("create simple bullet %s,%s at (%s)   v=%s,angle=%s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5])			if nodedata.attr[6]=='true' then ret=ret..",aim to player" end			return ret		end,		tohead=function(nodedata)			return string.format("last=New(_straight,%s)\n",table.concat(nodedata.attr,","))		end,	},	bulletcreatestraightex={		{'Style','bulletstyle',CheckExpr},		{'Color','color',CheckExpr},		{'Position','any',CheckPos},		{'Number','any',CheckExpr},		{'Interval (in frames)','any',CheckExpr},		{'Velocity start','any',CheckExpr},		{'Velocity end','any',CheckExpr},		{'Angle','any',CheckExpr},		{'Angle spread','any',CheckExpr},		{'Aim to player','bool',CheckExpr},		{'Rotation Velocity','any',CheckExpr},		{'Stay on create','bool',CheckExpr},		{'Destroyable','bool',CheckExpr},		disptype='create simple bullets',		default={['type']='bulletcreatestraightex',attr={'arrow_big','COLOR_RED','self.x,self.y','5','0','3','4','0','0','false','0','true','true'}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata)			local attr=nodedata.attr			local ret=string.format("create %s simple bullet(s) %s,%s at (%s)   interval=%s,v=%s~%s,angle=%s,spread=%s",attr[4],attr[1],attr[2],attr[3],attr[5],attr[6],attr[7],attr[8],attr[9])			if attr[10]=='true' then ret=ret..",aim to player" end			return ret		end,		tohead=function(nodedata)			return string.format("_create_bullet_group(%s,self)\n",table.concat(nodedata.attr,","))		end,	},	bulletclear={		{'Convert to faith','bool',CheckExpr},		{'Clear indestructible','bool',CheckExpr},		disptype='clear bullet',		default={["type"]='bulletclear',attr={'true','false'}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return "clear all bullets" end,		tohead=function(nodedata)			return string.format("_clear_bullet(%s,%s)\n",nodedata.attr[1],nodedata.attr[2])		end,	},	--	objectdefine={		{'Type name','any',CheckClassName},		disptype='define object',		editfirst=true,		allowparent={'root','folder'},		allowchild={'callbackfunc'},		totext=function(nodedata) return string.format("define object type %q",nodedata.attr[1]) end,		depth=0,		watch='objectdefine',		default=		{			["attr"]={				[1]="",			},			["type"]="objectdefine",			["expand"]=true,			["child"]={				[1]={					["attr"]={'','leaf','LAYER_ENEMY_BULLET','GROUP_ENEMY_BULLET','false','true','false','10'},					["type"]="objectinit",					["expand"]=true,					["child"]={						[1]={							["attr"]={							},							["type"]="task",							["child"]={							},						},					},				},			},		},		tohead=function(nodedata) className=nodedata.attr[1] return string.format("_editor_class[%q]=Class(_object)\n",className) end,	},	objectinit={		{'Parameter list','any',CheckParam},		{'Image','image',CheckNonBlank},		{'Layer','layer',CheckExpr},		{'Group','group',CheckExpr},		{'Hide','bool',CheckExpr},		{'Bound','bool',CheckExpr},		{'Auto rotation','bool',CheckExpr},		{'Hit point','any',CheckExpr},		disptype='on create object',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return string.format("on create: (%s)",nodedata.attr[1]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[1]) then p="_" else p=nodedata.attr[1] end			return string.format("_editor_class[%q].init=function(self,_x,_y,%s)\    self.x,self.y=_x,_y\	self.img=%q\	self.layer=%s\	self.group=%s\	self.hide=%s\	self.bound=%s\	self.navi=%s\	self.hp=%s\	self.maxhp=%s\	self._servants={}\	self._blend,self._a,self._r,self._g,self._b='',255,255,255,255\",className,p,nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8],nodedata.attr[8]) end,		tofoot=function(nodedata) return "end\n" end,		check=function(nodedata)			if not (watchDict.image[nodedata.attr[2]] or nodedata.attr[2]=='leaf') then return string.format('image %q does not exist',nodedata.attr[2]) end		end,	},	objectcreate={		{'Type name','selecttype',CheckNonBlank},		{'Position','any',CheckPos},		{'Parameter','param',CheckExprOmit},		disptype='create object',		editfirst=true,		default={["type"]='objectcreate',attr={'','self.x,self.y',''}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format("create object of type %q at (%s) with parameter %s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3]) end,		tohead=function(nodedata)			local p			if IsBlank(nodedata.attr[3]) then p="_" else p=nodedata.attr[3] end			return string.format("last=New(_editor_class[%q],%s,%s)\n",nodedata.attr[1],nodedata.attr[2],p)		end,		check=function(nodedata)			if not watchDict.objectdefine[nodedata.attr[1]] then return string.format('object type %q does not exist',nodedata.attr[1]) end			if paramNumDict[nodedata.attr[1]]~=CalcParamNum(nodedata.attr[3]) then return "number of parameter is incorrect" end		end,	},	--	connect={		{'Master','any',CheckExpr},		{'Servant','any',CheckExpr},		{'Damage transfer','any',CheckExpr},		{'Connect death','bool',CheckExpr},		default={['type']='connect',attr={'self','last','0','true'}},		forbidparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format('set %s as servant of %s',nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format('_connect(%s,%s,%s,%s)\n',nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4]) end,	},	setrelpos={		{'Position','any',CheckPos},		{'Rotation','any',CheckExpr,'self.rot'},		{'Follow master\'s rotation','bool',CheckExpr,'false'},		disptype='set relative position',		default={['type']='setrelpos',attr={'0,0','self.rot','false'}},		needancestor={'enemydefine','objectdefine','laserdefine','bulletdefine'},		forbidparent={'enemyinit','objectinit','laserinit','bulletinit'},		allowchild={},		totext=function(nodedata)			local ret=string.format('set position to (%s) relatively to master, set rot to %s',nodedata.attr[1],nodedata.attr[2])			if nodedata.attr[3]=='true' then ret=ret..', follow master\'s rot' end			return ret		end,		tohead=function(nodedata) return string.format('_set_rel_pos(self,%s,%s,%s)\n',nodedata.attr[1],nodedata.attr[2],nodedata.attr[3]) end,	},	--	setv={		{'Unit','any',CheckExpr},		{'Velocity','any',CheckExpr},		{'Angle','any',CheckExpr},		{'Aim to player','bool',CheckExpr},		{'Set rotation','bool',CheckExpr},		disptype='set velocity',		forbidparent={'folder','root'},		allowchild={},		default={['type']='setv',attr={'self','3','0','false','true'}},		totext=function(nodedata)			local aim			if nodedata.attr[4]=='true' then aim=' aim to player' else aim='' end			return string.format("set %s's velocity=%s angle=%s%s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],aim)		end,		tohead=function(nodedata)			return string.format("SetV2(%s,%s,%s,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[5],nodedata.attr[4])		end,	},	bulletchangestyle={		{'Bullet','any',CheckExpr},		{'Style','bulletstyle',CheckExpr},		{'Color','color',CheckExpr},		disptype='change bullet\'s style and color',		forbidparent={'folder','root'},		allowchild={},		default={['type']='bulletchangestyle',attr={'self','arrow_big','COLOR_RED'}},		totext=function(nodedata) return string.format("set %s's style to %s and color to %s",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3]) end,		tohead=function(nodedata)			return string.format("ChangeBulletImage(%s,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3])		end,	},	setcolor={		{'Object','any',CheckExpr},		{'Blend mode','blend',CheckExprOmit},		{'Alpha','any',CheckExpr},		{'Red','any',CheckExpr},		{'Green','any',CheckExpr},		{'Blue','any',CheckExpr},		disptype='change object\'s color and blend mode',		forbidparent={'folder','root'},		allowchild={},		default={['type']='setcolor',attr={'self','','255','255','255','255'}},		totext=function(nodedata) return string.format("set %s's color to (%s,%s,%s,%s) and blend mode to %q",nodedata.attr[1],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[2]) end,		tohead=function(nodedata)			return string.format("_object.set_color(%s,%q,%s,%s,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6])		end,	},	objectsetimg={		{'Object','any',CheckExpr},		{'Image','image',CheckNonBlank},		disptype='change object\'s image',		forbidparent={'folder','root'},		allowchild={},		default={['type']='objectsetimg',attr={'self',''}},		totext=function(nodedata) return string.format("set %s's image to %q",nodedata.attr[1],nodedata.attr[2]) end,		tohead=function(nodedata)			return string.format("%s.img=%q\n",nodedata.attr[1],nodedata.attr[2])		end,	},	unitforeach={		{'Group','group',CheckExpr},		disptype='for each unit in group',		forbidparent={'folder','root'},		forbidancestor={'unitforeach'},		totext=function(nodedata) return string.format("for each unit in group %s",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("for _,unit in ObjList(%s) do\n",nodedata.attr[1])		end,		tofoot=function(nodedata)			return "end\n"		end,	},	unitkill={		{'Unit','any',CheckExpr},		{'Trigger event','bool',CheckExpr},		disptype='kill unit',		forbidparent={'folder','root'},		allowchild={},		default={['type']='unitkill',attr={'self','true'}},		totext=function(nodedata) return string.format("kill %s",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("_kill(%s,%s)\n",nodedata.attr[1],nodedata.attr[2])		end,	},	unitdel={		{'Unit','any',CheckExpr},		{'Trigger event','bool',CheckExpr},		disptype='delete unit',		forbidparent={'folder','root'},		allowchild={},		default={['type']='unitdel',attr={'self','true'}},		totext=function(nodedata) return string.format("delete %s",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("_del(%s,%s)\n",nodedata.attr[1],nodedata.attr[2])		end,	},	--	bossdefine={		{'Type name','any',CheckClassName},		{'Displayed name','any',CheckNonBlank},		{'Position','any',CheckPos},		{'Spell Card Background','selecttype'},		{'Image','resfile'},		{'nCol','any',CheckExpr},		{'nRow','any',CheckExpr},		{'Collision size','any',CheckExpr},		{'Animation interval','any',CheckExpr},		disptype='define boss',		editfirst=true,		default={					["attr"]={"","Name","240,384","","","4","3","16,16","8"},					["type"]="bossdefine",					expand=true,					["child"]={						[1]={							["attr"]={"0,144","60","MOVE_NORMAL",},							["type"]="bossmoveto",						},						[2]={							["attr"]={"","2","15","60","600","0","0","0","false"},							["type"]="bossspellcard",							["expand"]=true,							["child"]={								[1]={									["attr"]={},									["type"]="bossscstart",									["expand"]=true,									["child"]={										[1]={											["attr"]={											},											["type"]="task",											["expand"]=true,											["child"]={												[1]={													["attr"]={'0,144','180','MOVE_NORMAL'},													["type"]="taskmoveto",												    },											},										},									},								},								[2]={									["attr"]={},									["type"]="bossscfinish",								},							},						},					},				},		allowparent={'root','folder'},		allowchild={'bossspellcard','bossmoveto','dialog'},		watch='bossdefine',		totext=function(nodedata) return string.format("define boss %q",nodedata.attr[1]) end,		depth=0,		tohead=function(nodedata)			className=nodedata.attr[1]			local scbg			if IsBlank(nodedata.attr[4]) then				scbg="spellcard_background"			else				scbg=string.format("_editor_class[%q]",nodedata.attr[4])			end			if IsBlank(nodedata.attr[5]) then				return string.format("_editor_class[%q]=Class(boss)\_editor_class[%q].cards={}\_editor_class[%q].init=function(self)\    boss.init(self,%s,%q,self.class.cards,New(%s))\end\n"				,className,className,className,nodedata.attr[3],nodedata.attr[2],scbg)			else				local fn=wx.wxFileName(nodedata.attr[5]):GetFullName()				return string.format("LoadImageGroupFromFile('anonymous:'..%q,%q,false,%s,%s,%s)\_editor_class[%q]=Class(boss)\_editor_class[%q].cards={}\_editor_class[%q].init=function(self)\    boss.init(self,%s,%q,self.class.cards,New(%s))\	self.imgs={} for i=1,12 do self.imgs[i]='anonymous:'..%q..i end\	self.ani_intv=%s\end\n"				,fn,fn,nodedata.attr[6],nodedata.attr[7],nodedata.attr[8],className,className,className,nodedata.attr[3],nodedata.attr[2],scbg,fn,nodedata.attr[9])			end		end,		check=function(nodedata)			if not IsBlank(nodedata.attr[5]) then				local absfn=MakeFullPath(nodedata.attr[5])				if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end				local fn=wx.wxFileName(nodedata.attr[5]):GetFullName()				if not CheckAnonymous(fn,absfn) then return string.format("Repeated resource file name %q",fn) end				local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")				if msg then return msg end				f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))				f:close()			end			if nodedata.attr[4]~='' and (not watchDict.bgdefine[nodedata.attr[4]]) then return string.format('background type %q does not exist',nodedata.attr[4]) end		end,	},	bossspellcard={		{'Name','any'},		{'Protect time (seconds)','any',CheckExpr},		{'Full damage time (seconds)','any',CheckExpr},		{'Total time (seconds)','any',CheckExpr},		{'Hit point','any',CheckExpr},		{'Drop power','any',CheckExpr},		{'Drop faith','any',CheckExpr},		{'Drop point','any',CheckExpr},		{'Immune to bomb','bool',CheckExpr},		disptype='spell card',		default={				["attr"]={"","2","15","60","600","0","0","0","false"},				["type"]="bossspellcard",				["expand"]=true,				["child"]={					[1]={						["attr"]={},						["type"]="bossscstart",						["expand"]=true,						["child"]={							[1]={								["attr"]={								},								["type"]="task",								["expand"]=true,								["child"]={									[1]={										["attr"]={'0,144','180','MOVE_NORMAL'},										["type"]="taskmoveto",										},									},								},							},						},						[2]={							["attr"]={},							["type"]="bossscfinish",						},					},				},		depth=0,		allowchild={},		allowparent={'bossdefine'},		totext=function(nodedata)			if IsBlank(nodedata.attr[1]) then				return "non-spell card"			else				return string.format("spell card %q",nodedata.attr[1])			end		end,		tohead=function(nodedata) return string.format("_tmp_sc=boss.card.New(%q,%s,%s,%s,%s,{%s,%s,%s},%s)\n"			,nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8],nodedata.attr[9])			end,		tofoot=function(nodedata) return string.format("table.insert(_editor_class[%q].cards,_tmp_sc)\n",className) end	},	bossscstart={		allowparent={'bossspellcard'},		disptype='on start spell card',		forbiddelete=true,		totext=function(nodedata) return "on start" end,		tohead=function(nodedata) return "function _tmp_sc:init()\n" end,		tofoot=function(nodedata) return "end\n" end,	},	bossscfinish={		allowparent={'bossspellcard'},		disptype='on finish spell card',		forbiddelete=true,		totext=function(nodedata) return "on finish" end,		tohead=function(nodedata) return "function _tmp_sc:del()\n" end,		tofoot=function(nodedata) return "end\n" end,	},	dialog={		{'Can skip','bool',CheckExpr},		disptype='dialog',		default={				["attr"]={"true"},				["type"]="dialog",				["expand"]=true,				["child"]={{["type"]='dialogtask',attr={}}}				},		allowchild={},		allowparent={'bossdefine'},		totext=function(nodedata)				return "dialog"		end,		tohead=function(nodedata) return string.format("_tmp_sc=boss.dialog.New(%s)\nfunction _tmp_sc:init()\n\tlstg.player.dialog=true\n\tself.dialog_displayer=New(dialog_displayer)\n",nodedata.attr[1]) end,		tofoot=function(nodedata) return string.format("end\ntable.insert(_editor_class[%q].cards,_tmp_sc)\n",className) end	},	dialogtask={		disptype='task for dialog',		allowparent={},		forbiddelete=true,		totext=function(nodedata) return "create task" end,		tohead=function(nodedata) return "task.New(self,function()\n" end,		tofoot=function(nodedata) return "end)\n" end,	},	sentence={		{'Image','image',CheckNonBlank},		{'Position','leftright',CheckNonBlank},		{'Text','any'},		{'Time (in frames)','any',CheckExprOmit},		editfirst=true,		disptype='sentence',		needancestor={'dialogtask'},		allowchild={},		totext=function(nodedata)			return string.format("%s %s %q",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3])		end,		tohead=function(nodedata)			local t=nodedata.attr[4]			if t=="" then t="nil" end			return string.format("boss.dialog.sentence(self,%q,%q,%q,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3],t)		end,	},	bosscreate={		{'Type name','selecttype',CheckNonBlank},		{'Wait','bool',CheckExpr},		disptype='create boss',		editfirst=true,		needancestor={'stage'},		allowchild={},		totext=function(nodedata) return string.format("create boss %q",nodedata.attr[1]) end,		tohead=function(nodedata)			return string.format("local _boss_wait=%s local _ref=New(_editor_class[%q]) last=_ref\nif _boss_wait then while IsValid(_ref) do task.Wait() end end\n",nodedata.attr[2],nodedata.attr[1])		end,		check=function(nodedata)			if not watchDict.bossdefine[nodedata.attr[1]] then return string.format('boss type %q does not exist',nodedata.attr[1]) end		end,	},	bossmoveto={		{'Destination','any',CheckExpr},		{'nFrame','any',CheckExprOmit},		{'Mode','movetomode',CheckExprOmit},		disptype='boss move to',		allowparent={'bossdefine'},		allowchild={},		default={["attr"]={"0,144","60","MOVE_NORMAL"},["type"]="bossmoveto"},		totext=function(nodedata)			local nf			if IsBlank(nodedata.attr[2]) then nf='1' else nf=nodedata.attr[2] end			return "move to ("..nodedata.attr[1]..") in "..nf.." frame(s)"		end,		tohead=function(nodedata)			local nf,mode			if IsBlank(nodedata.attr[2]) then nf='1' else nf=nodedata.attr[2] end			if IsBlank(nodedata.attr[3]) then mode='MOVE_NORMAL' else mode=nodedata.attr[3] end			return string.format("table.insert(_editor_class[%q].cards,boss.move.New(%s,%s,%s))\n",className,nodedata.attr[1],nf,mode)		end,	},	bosscast={		needancestor={'bossdefine'},		disptype='boss cast',		allowchild={},		totext=function(nodedata) return "play a cast animation" end,		tohead=function(nodedata) return "boss.cast(self)\n" end,	},	bossshowaura={		{'Show aura','bool',CheckExpr},		disptype='show/hide boss aura',		needancestor={'bossdefine'},		allowchild={},		totext=function(nodedata) return "show/hide aura" end,		tohead=function(nodedata) return string.format("boss.show_aura(self,%s)\n",nodedata.attr[1]) end,	},	--	playsound={		{'Sound name','sound',CheckNonBlank},		{'Volume','any',CheckExpr},		{'Pan','any',CheckExpr},		disptype='play sound',		default={["type"]="playsound",attr={'tan00','0.1','self.x/256'}},		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return string.format("play sound %q volume %s",nodedata.attr[1],nodedata.attr[2]) end,		tohead=function(nodedata) return string.format("PlaySound(%q,%s,%s)\n",nodedata.attr[1],nodedata.attr[2],nodedata.attr[3]) end,		check=function(nodedata)			if not (watchDict.sound[nodedata.attr[1]] or resList.snd[nodedata.attr[1]]) then return string.format('sound %q does not exist',nodedata.attr[1]) end		end,	},	loadsound={		{'File path','resfile',CheckNonBlank},		{'Resource name','any',CheckNonBlank},		disptype='load sound',		editfirst=true,		watch='sound',		allowchild={},		allowparent={'root','folder'},		totext=function(nodedata) return string.format("load sound %q from %q",nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("LoadSound(%q,%q)\n",nodedata.attr[2],wx.wxFileName(nodedata.attr[1]):GetFullName()) end,		check=function(nodedata)			if resList.snd[nodedata.attr[2]] then return string.format("Repeated resource name %q (name already exists in THlib)",nodedata.attr[2]) end			if checkSoundName[nodedata.attr[2]]==nil then checkSoundName[nodedata.attr[2]]=true			else return string.format("Repeated resource name %q",nodedata.attr[2]) end			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()			if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end			local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")			if msg then return msg end			f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))			f:close()		end	},	playbgm={		{'Music name','any',CheckNonBlank},		disptype='play background music',		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return string.format("play background music %q",nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("_play_music(%q)\n",nodedata.attr[1]) end,	},	pausebgm={		disptype='pause background music',		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return "pause background music" end,		tohead=function(nodedata) return "_pause_music()\n" end,	},	resumebgm={		disptype='resume background music',		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return "resume background music" end,		tohead=function(nodedata) return "_resume_music()\n" end,	},	stopbgm={		disptype='stop background music',		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return "stop background music" end,		tohead=function(nodedata) return "_stop_music()\n" end,	},	loadbgm={		{'File path','resfile',CheckNonBlank},		{'Resource name','any',CheckNonBlank},		{'Loop end (seconds)','any',CheckExpr},		{'Loop length (seconds)','any',CheckExpr},		disptype='load background music',		editfirst=true,		watch='bgm',		allowchild={},		forbidparent={'root','folder'},		totext=function(nodedata) return string.format("load background music %q from %q",nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("LoadMusic(%q,%q,%s,%s)\n",nodedata.attr[2],wx.wxFileName(nodedata.attr[1]):GetFullName(),nodedata.attr[3],nodedata.attr[4]) end,		check=function(nodedata)			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			if checkBgmName[nodedata.attr[2]]==nil then				checkBgmName[nodedata.attr[2]]=nodedata.attr[1]				local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()				if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end				local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")				if msg then return msg end				f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))				f:close()			else				if checkBgmName[nodedata.attr[2]]==nodedata.attr[1] then									else					return string.format("Repeated resource name %q",nodedata.attr[2])				end			end		end	},	loadimage={		{'File path','resfile',CheckNonBlank},		{'Resource name','any',CheckNonBlank},		{'Mipmap','bool',CheckExpr},		{'Collision size','any',CheckExpr},		{'Rectangle collision','bool',CheckExpr},		{'Cut edge','any',CheckExpr,'0'},		disptype='load image',		editfirst=true,		default={["type"]='loadimage',attr={'','','true','0,0','false','0'}},		watch='image',		allowchild={},		allowparent={'root','folder'},		totext=function(nodedata) return string.format("load image %q from %q",nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("_LoadImageFromFile('image:'..%q,%q,%s,%s,%s,%s)\n",nodedata.attr[2],wx.wxFileName(nodedata.attr[1]):GetFullName(),nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6]) end,		check=function(nodedata)			if checkImageName[nodedata.attr[2]]==nil then checkImageName[nodedata.attr[2]]=true			else return string.format("Repeated resource name %q",nodedata.attr[2]) end			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()			if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end			local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")			if msg then return msg end			f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))			f:close()		end	},	loadani={		{'File path','resfile',CheckNonBlank},		{'Resource name','any',CheckNonBlank},		{'Mipmap','bool',CheckExpr},		{'nCol','any',CheckExpr},		{'nRow','any',CheckExpr},		{'Interval','any',CheckExpr},		{'Collision size','any',CheckExpr},		{'Rectangle collision','bool',CheckExpr},		disptype='load animation',		editfirst=true,		default={["type"]='loadani',attr={'','','true','1','1','4','0,0','false'}},		watch='image',		allowchild={},		allowparent={'root','folder'},		totext=function(nodedata) return string.format("load animation %q from %q",nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("LoadAniFromFile('ani:'..%q,%q,%s,%s,%s,%s,%s,%s)\n",nodedata.attr[2],wx.wxFileName(nodedata.attr[1]):GetFullName(),nodedata.attr[3],nodedata.attr[4],nodedata.attr[5],nodedata.attr[6],nodedata.attr[7],nodedata.attr[8]) end,		check=function(nodedata)			if checkAniName[nodedata.attr[2]]==nil then checkAniName[nodedata.attr[2]]=true			else return string.format("Repeated resource name %q",nodedata.attr[2]) end			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()			if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end			local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")			if msg then return msg end			f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))			f:close()		end	},	loadparticle={		{'File path','resfile',CheckNonBlank},		{'Resource name','any',CheckNonBlank},		{'Image','image',CheckParImage},		{'Collision size','any',CheckExpr},		{'Rectangle collision','bool',CheckExpr},		disptype='load particle effect',		editfirst=true,		default={["type"]='loadparticle',attr={'','','','0,0','false'}},		watch='image',		allowchild={},		allowparent={'root','folder'},		totext=function(nodedata) return string.format("load particle system %q from %q",nodedata.attr[2],nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("LoadPS('particle:'..%q,%q,%q,%s,%s)\n",nodedata.attr[2],wx.wxFileName(nodedata.attr[1]):GetFullName(),nodedata.attr[3],nodedata.attr[4],nodedata.attr[5]) end,		check=function(nodedata)			if checkParName[nodedata.attr[2]]==nil then checkParName[nodedata.attr[2]]=true			else return string.format("Repeated resource name %q",nodedata.attr[2]) end			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()			if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end			local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")			if msg then return msg end			f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))			f:close()			if not (watchDict.imageonly[nodedata.attr[3]] or parimg[nodedata.attr[3]]) then return string.format('image %q does not exist',nodedata.attr[3]) end		end	},	bgdefine={		{'Type name','any',CheckClassName},		disptype='define boss\'s background',		editfirst=true,		allowparent={'root','folder'},		watch='bgdefine',		allowchild={'bglayer'},		totext=function(nodedata) return string.format("define background type %q",nodedata.attr[1]) end,		tohead=function(nodedata) return string.format("_editor_class[%q]=Class(_spellcard_background)\n_editor_class[%q].init=function(self)\n    _spellcard_background.init(self)\n",nodedata.attr[1],nodedata.attr[1]) end,		tofoot=function(nodedata) return 'end\n' end,	},	bglayer={		{'Image','image',CheckNonBlank},		{'Is tile','bool',CheckExpr},		{'x','any',CheckExpr},		{'y','any',CheckExpr},		{'rot','any',CheckExpr},		{'vx','any',CheckExpr},		{'vy','any',CheckExpr},		{'omiga','any',CheckExpr},		{'Blend mode','blend',CheckExprOmit},		{'hscale','any',CheckExpr},		{'vscale','any',CheckExpr},		{'Extra init action','any',CheckCode},		{'Extra frame action','any',CheckCode},		disptype='layer',		editfirst=true,		default={["type"]='bglayer',attr={'','false','0','0','0','0','0','0','','1','1','',''}},		allowparent={'bgdefine'},		totext=function(nodedata) return string.format("layer %q",nodedata.attr[1]) end,		tohead=function(nodedata)			local attr=nodedata.attr			local init_code,frame_code			if IsBlank(attr[12]) then  init_code='nil' else  init_code=string.format('function(layer) %s end',attr[12]) end			if IsBlank(attr[13]) then frame_code='nil' else frame_code=string.format('function(layer) %s end',attr[13]) end			return string.format('_spellcard_background.AddLayer(self,%q,%s,%s,%s,%s,%s,%s,%s,%q,%s,%s,%s,%s)\n',				attr[1],attr[2],attr[3],attr[4],attr[5],attr[6],attr[7],				attr[8],attr[9],attr[10],attr[11],init_code,frame_code			)		end,		check=function(nodedata)			if not watchDict.imageonly[nodedata.attr[1]] then return string.format('image %q does not exist',nodedata.attr[1]) end		end	},	patch={		{'path','resfile',CheckNonBlank},		editfirst=true,		allowparent={'root','folder'},		allowchild={},		totext=function(nodedata) return string.format("patch %q",wx.wxFileName(nodedata.attr[1]):GetName()) end,		tohead=function(nodedata) return string.format("Include%q\n",wx.wxFileName(nodedata.attr[1]):GetFullName()) end,		check=function(nodedata)			local absfn=MakeFullPath(nodedata.attr[1])			if not wx.wxFileName(absfn):FileExists() then return string.format("Resource file %q does not exist",absfn) end			local fn=wx.wxFileName(nodedata.attr[1]):GetFullName()			if not CheckResFileInPack(fn) then return string.format("Repeated resource file name %q",fn) end			local f,msg=io.open("editor\\tmp\\_pack_res.bat","a")			if msg then return msg end			f:write(string.format('zip -j "mod\\%s.zip" "%s"\n',outputName,absfn))			f:write(string.format('cd /D "%s" \n',wx.wxFileName(absfn):GetPath(wx.wxPATH_GET_VOLUME)))			f:write(string.format('"%s\\zip" -r "%s\\mod\\%s.zip" THlib\n',cwd,cwd,outputName))			f:write(string.format('cd /D "%s" \n',cwd))			f:close()		end	}}enumType={	any={},	resfile={},	bool={'true','false'},	['for']={'i','j','k','l','m','n'},	movetomode={'MOVE_NORMAL','MOVE_ACCEL','MOVE_DECEL','MOVE_ACC_DEC'},	bulletstyle={'arrow_big','arrow_small','gun_bullet','butterfly','square',				'ball_small','ball_mid','ball_big','ball_huge','star_small','star_big',				'grain_a','grain_b','grain_c','kite','knife','water_drop','mildew','ellipse'},	color={'COLOR_RED','COLOR_PURPLE','COLOR_BLUE','COLOR_CYAN','COLOR_GREEN','COLOR_YELLOW','COLOR_ORANGE','COLOR_GRAY'},	sound={},	image={},	selecttype={},	param={},	selectenemystyle={},	event={'frame','render','colli','kill','del'},	leftright={'left','right'},	layer={		'LAYER_BG',		'LAYER_BG+1',		'LAYER_BG-1',		'LAYER_ENEMY',		'LAYER_ENEMY+1',		'LAYER_ENEMY-1',		'LAYER_PLAYER_BULLET',		'LAYER_PLAYER_BULLET+1',		'LAYER_PLAYER_BULLET-1',		'LAYER_PLAYER',		'LAYER_PLAYER+1',		'LAYER_PLAYER-1',		'LAYER_ITEM',		'LAYER_ITEM+1',		'LAYER_ITEM-1',		'LAYER_ENEMY_BULLET',		'LAYER_ENEMY_BULLET+1',		'LAYER_ENEMY_BULLET-1',		'LAYER_ENEMY_BULLET_EF',		'LAYER_ENEMY_BULLET_EF+1',		'LAYER_ENEMY_BULLET_EF-1',		'LAYER_TOP',		'LAYER_TOP+1',		'LAYER_TOP-1',	},	group={		'GROUP_GHOST',		'GROUP_ENEMY_BULLET',		'GROUP_ENEMY',		'GROUP_PLAYER_BULLET',		'GROUP_PLAYER',		'GROUP_INDES',		'GROUP_ITEM',	},	bgstage={'temple','magic_forest','bamboo'},	blend={'','mul+add','mul+alpha','add+add','add+alpha',},}for k,v in pairs(nodeType) do	v.name=k	if not v.disptype then v.disptype=k end	if v.allowchild then for _,typename in ipairs(v.allowchild) do v.allowchild[typename]=true end end	if v.forbidchild then for _,typename in ipairs(v.forbidchild) do v.forbidchild[typename]=true end end	if v.allowparent then for _,typename in ipairs(v.allowparent) do v.allowparent[typename]=true end end	if v.forbidparent then for _,typename in ipairs(v.forbidparent) do v.forbidparent[typename]=true end end	if v.needancestor then for _,typename in ipairs(v.needancestor) do v.needancestor[typename]=true end end	if v.forbidancestor then for _,typename in ipairs(v.forbidancestor) do v.forbidancestor[typename]=true end end	if v.watch then Tree.watch[v.watch]={} endend